(example)[https://github.com/cboulay/psmoveapi/blob/master/examples/c/test_opengl3.cpp]

Next, we need a way for the module to trigger events to let the game know that something happened. Event messaging is typically complicated, and UE4 is no exception.


### Interfaces

Interfaces can be Blueprint interfaces as well as defined in C++. We need C++ because we are accessing a C++ library (i.e., the psmoveapi). See the [UE4 Wiki tutorial on C++ interfaces](https://wiki.unrealengine.com/Interfaces_in_C%2B%2B). Also [here](https://answers.unrealengine.com/questions/152680/interface-in-c-can-you-pass-variables-between-obje.html).

#### Defining an interface in C++

See Source/Public/PSMoveEventInterface.h and Souce/Private/PSMoveEventInterface.cpp 

In our interface header we declare static member variables and static functions.

#### Implementing an interface in C++

(Multiply-) Inherit from the interface in a C++ class. Here I do that in Source/Classes/PSMoveComponent.h


There needs to be a mechanism to communicate between our module's functionality and the created class. As far as I can tell, there are two ways to do this, and neither of them are very well documented:

1. UE4's delegate system
2. Interfaces

### UE4's delegate system

I have not worked much with [UE4's delegate system](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Delegates/index.html), though I hope to try it eventually.





#### Defining an interface in Blueprints

We are not doing this here, though it is [well documented](https://docs.unrealengine.com/latest/INT/Engine/Blueprints/UserGuide/Types/Interface/index.html).

#### Implementing an interface in Blueprint

This is probably the [best-documented part of interfaces](https://docs.unrealengine.com/latest/INT/Engine/Blueprints/UserGuide/Types/Interface/UsingInterfaces/index.html).



This class is decorated with the
[UINTERFACE macro](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Interfaces/index.html)
and inherits from .
This is the class that will be consumed by the game.

Side Note:
In some cases (I'm not sure, [but when a UObject is involved anyway](https://answers.unrealengine.com/questions/2649/how-exactly-do-game-plugins-work.html))
it will be necessary to use [MYMODULE_API -style interface](http://adamitskiy.wix.com/daniel#!ue4-programming-api-fundamentals/c1f6q).

We then inherit from the interface within the plugin's private implementation.
The game can now consume the plugin through the interface.





One convenient way to have your Plugin functions used by the game is through event delegation. Again, there seems to be two ways to do this:
1. Create a class that [implements the interface](https://wiki.unrealengine.com/Interfaces_in_C%2B%2B), and in its implementation it calls BlueprintImplementableEvents. Then you can use this class in the game. Some links suggest this style (i.e., interfaces) cannot be implemented in blueprints but [maybe that is wrong](https://wiki.unrealengine.com/Interfaces_And_Blueprints). TODO EXAMPLE
2. [UE4s event delegation system](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Delegates/Events/index.html). TODO EXAMPLE

## Bottom-Up

`PSMovePlugin.uplugin` defines a module named `PSMovePlugin`.

`PSMovePlugin.Build.cs` defines the Public and Private include paths and links the psmoveapi libraries.

(I think) The build tool searches the public and private include paths for `IMPLEMENT_MODULE( FPSMovePlugin, PSMovePlugin )`. With that identified, we know that the implementation of the `PSMovePlugin` module can be found in the `FPSMovePlugin` class.

This class (declared in `Private/FPSMovePlugin.h, inherits from Public/IPSMovePlugin.h`, necessarily inherits from `IModuleInterface`; implemented in `Private/FPSMovePlugin.cpp`), defines `SetDelegate(PSMoveDelegate*)`, `PSMoveTick` (poll for the latest data then callsâ€¦), and `DelegateTick`.



## Top-Down

[Interfaces](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Interfaces/index.html)

We need a PlayerController that we can use to control a pawn.
To do this, we create `APSMovePlayerController`, which inherits from `APlayerController` and others that inherit from `PSMoveDelegate`. The `APSMovePlayerController` defines virtual functions `BeginPlay()`, `EndPlay(const EEndPlayReason::Type EndPlayReason)`, and `Tick(DeltaTime)`. Each of these calls their `Super`, and then the PSMove-specific functions (`PSMoveStartup`, `PSMoveShutdown`, `PSMoveTick`) defined by `PSMoveDelegate`.

